

# zip(*)可以用于快捷的矩阵行列转换

```
matrix = [[3,7,8],[9,11,13],[15,16,17]]
print([col for col in zip(*matrix)])   # [(3, 9, 15), (7, 11, 16), (8, 13, 17)]
```

星号（*）操作符可以解包（unpacking），即将 matrix 的元素（也是列表）解成多个参数给 zip()，从而将 3 个列表重新组合。
解包操作符对于 zip 对象同样适用，因为 zip() 本身是一次行列转换的操作，若将它解包后作为参数给 zip()，等于再做一次行列转换，也就是回到了原点（除了最后的结果是元组）：


# 另一种形式的dp

https://leetcode.cn/problems/domino-and-tromino-tiling/


常规的dp是dp[i] = n*dp[i-1]  + m*dp[i-2] 这种形式，dp[i-1]只有一个值

这道题的dp形式是计算每种情况可以由上一次的某些情况变换得到。 可以理解为dp[i-1]有四个值
```
class Solution(object):
    def numTilings(self, N):
        MOD = 10**9 + 7
        dp = [1, 0, 0, 0]
        for _ in xrange(N):
            ndp = [0, 0, 0, 0]
            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD
            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD
            ndp[0b10] = (dp[0b00] + dp[0b01]) % MOD
            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD
            dp = ndp
        return dp[0]
```
