

# 排序算法
目标：将一个无序的数组按照升序进行排序


# 选择排序
每次从未排序的数组中选择最小的放在 已经排序的数组末尾。

# 插入排序
每次从未排序的数组中选择第一个，插入到已经排序的合理的位置上

# 冒泡排序
每次对相邻的两个位置的数字进行比较排序，如为降序则交换位置


# 归并排序
```
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def merge_sort(nums,left,right):       # 对区间位置[left,right]的数进行排序
            if left==right:         #  若区间中只有一个数，不必排序
                return
            mid=(left+right)>>1          # 将较大的区间[left,right]一分为二:[left,mid],[mid+1，right]
            merge_sort(nums,left,mid)
            merge_sort(nums,mid+1,right)
            i,j=left,mid+1            # i,j分别记录[left,mid],[mid+1，right]两个区间的起点
            tmp=[]                # tmp记录[left,right]的排序结果
            while i<=mid or j<=right:
                if i>mid or (j<=right and nums[i]>nums[j]):
                    tmp.append(nums[j])
                    j+=1    
                else:
                    tmp.append(nums[i])
                    i+=1
            nums[left:right+1]=tmp[:]        # tmp的记录结果传回nums 
        merge_sort(nums,0,len(nums)-1)
        return nums
```

# 快速排序

```
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def quicksort(nums,left,right):
            if left>=right:
                return
            pivot=randrange(left,right+1)       # pivot取随机位置
            nums[pivot],nums[left]=nums[left],nums[pivot]    # 先把pivot值放在最左侧，这是为了确保在while循环的互换过程中不会把pivot位置上的值换掉
            start,end=left,right
            while left<right:
                while left<right and nums[right]>nums[start]:       # 这里left，right类似看作指针（便于讲解）
                    right-=1                         # 若右侧值大于pivot值，右指针right顺利的左移
                while left<right and nums[left]<=nums[start]:
                    left+=1                         # 若右侧值大于pivot值，左指针left顺利的左移
                nums[left],nums[right]=nums[right],nums[left]      # 若left，right都卡住，说明所指的值不满足要求，right小于pivot，left大于pivot，互换。
            nums[start],nums[left]=nums[left],nums[start]     #  最终left，right会和，left停在pivot本应存在的位置上，互换left位置上的值和之前寄存在起始位置上的pivot对应值
            quicksort(nums,start,left-1)         # 此后pivot对应值在数组中的排序位置确定，
            quicksort(nums,left+1,end)           # 只需为start到left-1位置，left+1到right位置的数继续排序
        left,right=0,len(nums)-1
        quicksort(nums,left,right)
        return nums

```


# 希尔排序

# 堆排序
```
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def heapify(nums,i,end):
            while i*2+1<=end:
                if i*2+2<=end and nums[i*2+1]<nums[i*2+2]:      # 找出i结点的叶结点中的最大值，用nxt标记位置
                    nxt=i*2+2
                else:
                    nxt=i*2+1
                if nums[i]<nums[nxt]:           # 若i结点的值小于叶结点中的最大值
                    nums[i],nums[nxt]=nums[nxt],nums[i]       # 交换这两个值
                    i=nxt      # 值交换后，从被改动值的叶结点开始往下缕清顺序
                else:
                    break

        def build_heap(nums):        # 初始建堆
            for i in range(len(nums)//2-1,-1,-1):     # 由于堆的性质，从最后一个非叶结点排起
                heapify(nums,i,len(nums)-1)
                        
        def heapsort(nums):
            build_heap(nums)
            end=len(nums)-1
            while end>0:
                nums[end],nums[0]=nums[0],nums[end]      # 将上一个堆的堆顶值与数组末尾值互换
                end-=1                  # end已确定次序（为当前堆最大值），未排序的数范围变为[0,end-1]
                heapify(nums,0,end)      #  堆顶值变动后，从堆顶开始重新缕清顺序

        heapsort(nums)
        return nums

```

# 计数排序

# 桶排序
```
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for i in range(5):         #  十进制最高五位，排五趟
            box1=[[] for _ in range(10)]       # 设置box1，box2两组桶，分别放负数和正数
            box2=[[] for _ in range(10)]
            for num in nums:
                if num<0:
                    box1[num%(10**(i+1))//(10**i)].append(num)    # 负数放在box1
                else:
                    box2[num%(10**(i+1))//(10**i)].append(num)      # 正数（包括0）放在box2
            nums=[]             # 排完一趟后，依次取出，重新放回nums
            for num in box1:
                nums.extend(num)        # 先依次放负数
            for num in box2:
                nums.extend(num)        # 再依次放正数
        return nums        # 从最低位到最高位排完五趟后，整体排序完毕

```

# 基数排序

